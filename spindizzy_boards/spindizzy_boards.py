import asyncio
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from html import escape
import logging
import textwrap
import time
from typing import Dict

from feedgen.feed import FeedGenerator
from pyramid.config import Configurator
from pyramid.httpexceptions import HTTPNotFound, HTTPServiceUnavailable
from pyramid.response import Response
import pytz
import toml
from twitter.error import TwitterError
from wsgiref.simple_server import make_server

from muck_downloader import FakeMuckDownloader, MuckDownloader


_TIME_FORMAT = "%Y-%m-%d %I:%M %p"


class SpinDizzyBoards(object):
    """
    A class that is responsible for most of the functionality
    of the app.

    It includes all the view callables for the web app.

    It also includes a background process that is responsible
    for keeping content up to date.
     - Checks for new posts at a specified interval.
     - Updates the state for the web-app.
     - [Unimplemented] Sends out alerts to Twitter and Mastodon.
    """
    def __init__(self, config: Dict):
        """
        Args:
            config (dict): A parsed config.toml object.
        """
        if config['fake_muck']:
            self.downloader = FakeMuckDownloader(**config['muck'])
        else:
            self.downloader = MuckDownloader(**config['muck'])
        self.boards = [x[0] for x in config['muck']['boards']]
        self.board_names = {x[0]: x[1] for x in config['muck']['boards']}
        self.url_base = config['web']['url_base']
        self.tz = pytz.timezone(config['timezone'])
        self.feed_domain = config['web']['feed_domain']

        # Will be filled in by a background thread.
        self.current_content = {}
        self.feeds = {}

        # Start up our background task.
        self.interval = config['interval']
        self.executor = ThreadPoolExecutor(1)
        self.loop = asyncio.get_event_loop()
        self.download_task = asyncio.ensure_future(
            self.loop.run_in_executor(self.executor, self.background_download))

    def post2template(self, x):
        """
        This function does a little processing to turn the raw data
        associated with a post into the form a template expects.

        Right now the only real reason to do this is to provide a
        human-readable date generated by strftime(), but in the future
        we could also do some formatting (e.g., just enough to allow
        *italic* and **bold** text) and any other similar things
        here, if desired.
        """
        return { 'id': x['time'],
                 'humantime': datetime.fromtimestamp(x['time'], self.tz).strftime(_TIME_FORMAT),
                 'author_name': x['owner_name'],
                 'title': x['title'],
                 'content': x['content']
               }

    def _construct_feeds(self) -> Dict[str, Dict[str, str]]:
        """
        Takes the current content and returns a constructed dictionary
        of atom-formatted feeds. This method should only be
        called by the background thread.

        :return: A dictionary with string keys, one for each board
                 command and one for ``master``. The values are
                 XML-formated feeds.
        """
        def id_generator(name, ts):
            return('tag:{feed_domain},{date}:{name}'
                   .format(feed_domain=self.feed_domain,
                           date=datetime.fromtimestamp(ts).strftime('%Y-%m-%d'),
                           name=name))

        def translate_content_to_xhtml(content):
            """Try to render a board post as faithfully as possible in xhtml."""
            # Unfortunately most readers I find strip the style attribute so we'll probably have to work on this.
            return '<p style="white-space:pre-wrap;">{}</p>'.format(escape(content).replace('\n', '<br />'))

        # TODO(hyena): It would be more useful if these links were absolute.
        # Consider adding that if we ever make the web-app aware of its own
        # url.

        new_feeds = {}
        master_feedgen = FeedGenerator()
        master_feedgen.title("SpinDizzy Boards Master")
        master_feedgen.link({'href': '/sdb/atom', 'rel': 'self'})
        master_feedgen.description("All posts as scraped from SpinDizzy")
        master_feedgen.id(id_generator('master', 0))

        master_entry_list = []
        for board_command in self.current_content:
            board_feedgen = FeedGenerator()
            board_feedgen.title("SpinDizzy {}".format(self.board_names[board_command]))
            board_feedgen.link({'href': '/sdb/{}/atom'.format(board_command), 'rel': 'self'})
            board_feedgen.description("Posts scraped from {}"
                                      .format(self.board_names[board_command]))
            board_feedgen.id(id_generator(board_command, 0))
            for post in sorted(self.current_content[board_command].values(), key=lambda p: -p['time']):
                entry = board_feedgen.add_entry()
                entry.title(post['title'])
                # RSS insists on an email which is annoying.
                entry.author({'name': post['owner_name']})
                entry.updated(datetime.fromtimestamp(post['time'], tz=self.tz))
                entry.link({'href': '/sdb/{}/{}'.format(board_command, post['time']), 'rel': 'alternate'})
                entry.content(translate_content_to_xhtml(post['content']), type='xhtml')
                entry.id(id_generator(name='/sdb/{}/{}'.format(board_command, post['time']),
                                      ts=post['time']))
                master_entry_list.append(entry)
            new_feeds[board_command] = board_feedgen.atom_str(pretty=True)

        # Add the entries to the master feed in the right order.
        for entry in sorted(master_entry_list, key=lambda e: -e.updated().timestamp()):
            master_feedgen.add_entry(feedEntry=entry)
        new_feeds['master'] = master_feedgen.atom_str(pretty=True)

        return new_feeds

    def command_for_post(self, board: str, post_id: int):
        """ Generate the muck side command to read a given postid, given present board contents."""
        # This assumes that the posts are sorted by time.
        index = sorted(self.current_content[board].keys()).index(post_id) + 1
        return "{} {}".format(board, index)

    def url_for_post(self, board: str, post_id: int):
        # TODO(hyena): Pyramid has some nice utilities to construct URLs in a more portable way.
        url_base = self.url_base[:-1] if self.url_base.endswith('/') else self.url_base
        return "{}/sdb/{}/{}".format(url_base, board, post_id)

    def background_download(self):
        """Background task to download board content."""
        # TODO(hyena): This isn't especially fault tolerant right now.
        # If it dies in a recoverable fashion, we should log the error and retry.
        # Conversely if it dies to a logical or fatal error, we should kill the
        # the webserver too. Unfortunately right now if anything goes wrong, this
        # thread dies quietly.
        while True:
            next_runtime = time.time() + self.interval
            try:
                # Expose the downloaded content without waiting for sending announcements.
                # The GIL makes this safe.
                self.current_content = self.downloader.get_posts()
                self.feeds = self._construct_feeds()
            except:
                # Optimistically continue.
                logging.warn('Error while trying to retrieve boards', exc_info=True)
            # New content gotten. Rest if we can....
            sleep_length = next_runtime - time.time()
            if sleep_length > 0:
                time.sleep(sleep_length)

    ### View Callables.
    def list_boards(self, request):
        """View callable that shows a list of available boards."""
        loaded_boards = self.current_content.keys()
        boards = [x for x in self.boards if x in loaded_boards]
        return {'boards': boards,
                'board_names': self.board_names,
                }

    def list_posts(self, request):
        """View callable that shows all the posts on a particular board."""
        # Grab this at the start because it might get updated in a background thread.
        content = self.current_content
        board = request.matchdict['board_command'].lower()
        if board not in content:
            raise HTTPNotFound("No such board found.")
        return {'posts': [self.post2template(x)
                          for x in sorted(content[board].values(), key=lambda p: p['time'])],
                'board': board,
                'board_name': self.board_names[board],
               }

    def view_post(self, request):
        """View callable that shows the contents of a post."""
        # Grab this at the start because it might be updated by the background thread.
        content = self.current_content
        board = request.matchdict['board_command'].lower()
        postid = int(request.matchdict['post_id'])
        if board not in content or postid not in content[board]:
            raise HTTPNotFound("Post not found")
        post_ids = sorted(content[board].keys())
        post_pos = post_ids.index(postid)
        prev_post_id = content[board][post_ids[post_pos - 1]] if post_pos > 0 else None
        next_post_id = content[board][post_ids[post_pos + 1]] if post_pos + 1 < len(post_ids) else None
        return {'post': self.post2template(content[board][postid]),
                'post_index': post_pos + 1,
                'prev_post': self.post2template(prev_post_id) if prev_post_id is not None else None,
                'next_post': self.post2template(next_post_id) if next_post_id is not None else None,
                'board': board,
                'board_name': self.board_names[board],
               }

    def master_feed(self, request):
        """View callable that returns an atom feed for all boards."""
        if not self.feeds:
            # Tell the user to come back later.
            raise HTTPServiceUnavailable(headers={'Retry-After': '60'})
        return Response(self.feeds['master'],
                        content_type='application/atom+xml')

    def board_feed(self, request):
        """View callable that returns an atom feed for a particular board."""
        board = request.matchdict['board_command'].lower()
        if board not in self.board_names:
            raise HTTPNotFound("No such board found.")
        elif not self.feeds:
            # Tell the user to come back later.
            raise HTTPServiceUnavailable(headers={'Retry-After': '60'})
        elif board not in self.feeds:
            raise HTTPNotFound("No such board found.")
        return Response(self.feeds[board],
                        content_type='application/atom+xml')


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    with open("config.toml") as config_file:
        conf_toml = toml.loads(config_file.read())
    worker = SpinDizzyBoards(conf_toml)

    # Set up webapp routes.
    # Note that this could also be accomplished with pyramid's traversal functionality.
    # However, I think that for this usage case that adds more complexity than it's worth.
    config = Configurator()
    config.include("pyramid_jinja2")

    def setup_routes(config):
        """Sets up all routes."""
        config.add_static_view(name='static', path='static')

        config.add_route('board_list', '/')
        config.add_view(worker.list_boards, route_name='board_list', renderer="templates/boardlist.jinja2")

        # n.b. this must be registered before the /board_command route.
        config.add_route('master_feed', '/atom')
        config.add_view(worker.master_feed, route_name='master_feed')

        config.add_route('posts_list', '/{board_command}')
        config.add_view(worker.list_posts, route_name='posts_list', renderer="templates/postlist.jinja2")

        config.add_route('view_post', '/{board_command}/{post_id:\d+}')
        config.add_view(worker.view_post, route_name='view_post', renderer="templates/post.jinja2")

        config.add_route('board_feed', '/{board_command}/atom')
        config.add_view(worker.board_feed, route_name='board_feed')

    config.include(setup_routes, route_prefix='sdb')
    config.add_notfound_view(lambda x: HTTPNotFound(), append_slash=True)
    # TODO(hyena): Set up a *real* wsgi environment.
    app = config.make_wsgi_app()
    server = make_server('0.0.0.0', conf_toml['web']['port'], app)
    server.serve_forever()
